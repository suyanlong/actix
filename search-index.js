var searchIndex = {};
searchIndex["actix"] = {"doc":"Actix is a rust actor framework.","items":[[3,"SpawnHandle","actix","Spawned future handle. Could be used for cancelling spawned future.",null,null],[3,"Arbiter","","Event loop controller",null,null],[3,"Address","","Address of the actor",null,null],[3,"SyncAddress","","`Send` address of the actor. Actor can run in differend thread",null,null],[3,"Context","","Actor execution context",null,null],[3,"FramedContext","","Actor execution context for Framed object",null,null],[3,"Request","","`Request` is a `Future` which represents asyncronous message sending process.",null,null],[3,"Response","","`Response` represents asyncronous message handling process.",null,null],[3,"Registry","","Actors registry",null,null],[3,"SystemRegistry","","System wide actors registry",null,null],[3,"System","","System is an actor which manages process.",null,null],[3,"SystemRunner","","Helper object that runs System's event loop",null,null],[3,"Supervisor","","Actor supervisor",null,null],[4,"ActorState","","Actor execution state",null,null],[13,"Started","","Actor is started.",0,null],[13,"Running","","Actor is running.",0,null],[13,"Stopping","","Actor is stopping.",0,null],[13,"Stopped","","Actor is stopped.",0,null],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"actorstate"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"spawnhandle"}}],[11,"hash","","",1,null],[11,"next","","Get next handle",1,{"inputs":[{"name":"self"}],"output":{"name":"spawnhandle"}}],[11,"default","","",1,{"inputs":[],"output":{"name":"spawnhandle"}}],[11,"started","","",2,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[11,"new","","Spawn new thread and run event loop in spawned thread. Returns address of newly created arbiter.",2,{"inputs":[{"name":"t"}],"output":{"generics":["arbiter"],"name":"syncaddress"}}],[11,"name","","Returns current arbiter's address",2,{"inputs":[],"output":{"name":"string"}}],[11,"arbiter","","Returns current arbiter's address",2,{"inputs":[],"output":{"generics":["arbiter"],"name":"address"}}],[11,"system","","This function returns system address,",2,{"inputs":[],"output":{"generics":["system"],"name":"syncaddress"}}],[11,"system_arbiter","","This function returns system address,",2,{"inputs":[],"output":{"generics":["arbiter"],"name":"syncaddress"}}],[11,"system_name","","This function returns system name,",2,{"inputs":[],"output":{"name":"string"}}],[11,"system_registry","","This function returns system registry,",2,{"inputs":[],"output":{"name":"systemregistry"}}],[11,"handle","","This function returns current event loop's handle,",2,{"inputs":[],"output":{"name":"handle"}}],[11,"registry","","This function returns arbiter's registry,",2,{"inputs":[],"output":{"name":"registry"}}],[11,"start","","Start new arbiter and then start actor in created arbiter. Returns `SyncAddress` of created actor.",2,{"inputs":[{"name":"f"}],"output":{"name":"syncaddress"}}],[11,"handle","","",2,{"inputs":[{"name":"self"},{"name":"stoparbiter"},{"name":"context"}],"output":null}],[11,"handle","","",2,{"inputs":[{"name":"self"},{"name":"startactor"},{"name":"context"}],"output":{"name":"syncaddress"}}],[11,"handle","","",2,{"inputs":[{"name":"self"},{"name":"execute"},{"name":"context"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"connected","","Indicates if address is still connected to the actor.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"send","","Send message `M` to actor `A`. Communication channel to the actor is unbuonded.",3,{"inputs":[{"name":"self"},{"name":"m"}],"output":null}],[11,"call","","Send message to actor `A` and asyncronously wait for response.",3,{"inputs":[{"name":"self"},{"name":"b"},{"name":"m"}],"output":{"name":"request"}}],[11,"call_fut","","Send message to the actor `A` and asyncronously wait for response.",3,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"generics":["result"],"name":"receiver"}}],[11,"upgrade","","Upgrade address to SyncAddress.",3,{"inputs":[{"name":"self"}],"output":{"generics":["syncaddress"],"name":"receiver"}}],[11,"subscriber","","Get `Subscriber` for specific message type",3,{"inputs":[{"name":"self"}],"output":{"generics":["subscriber"],"name":"box"}}],[11,"send","","",3,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"name":"result"}}],[11,"boxed","","",3,{"inputs":[{"name":"self"}],"output":{"generics":["subscriber"],"name":"box"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"connected","","Indicates if address is still connected to the actor.",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"send","","Send message `M` to actor `A`. Message cold be sent to actor running in different thread.",4,{"inputs":[{"name":"self"},{"name":"m"}],"output":null}],[11,"call","","Send message to actor `A` and asyncronously wait for response.",4,{"inputs":[{"name":"self"},{"name":"b"},{"name":"m"}],"output":{"name":"request"}}],[11,"call_fut","","Send message to actor `A` and asyncronously wait for response.",4,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"generics":["result"],"name":"syncreceiver"}}],[11,"subscriber","","Get `Subscriber` for specific message type",4,{"inputs":[{"name":"self"}],"output":{"generics":["subscriber"],"name":"box"}}],[11,"send","","",4,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"name":"result"}}],[11,"boxed","","",4,{"inputs":[{"name":"self"}],"output":{"generics":["subscriber"],"name":"box"}}],[11,"stop","","Stop actor execution",5,{"inputs":[{"name":"self"}],"output":null}],[11,"terminate","","Terminate actor execution",5,{"inputs":[{"name":"self"}],"output":null}],[11,"state","","Actor execution state",5,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[11,"spawn","","",5,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[11,"wait","","",5,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"cancel_future","","",5,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"unsync_sender","","",5,{"inputs":[{"name":"self"}],"output":{"generics":["contextprotocol"],"name":"unboundedsender"}}],[11,"unsync_address","","",5,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[11,"sync_address","","",5,{"inputs":[{"name":"self"}],"output":{"name":"syncaddress"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"pack","","",5,{"inputs":[{"name":"m"},{"generics":["syncsender"],"name":"option"},{"name":"bool"}],"output":{"name":"envelope"}}],[11,"pack","","",6,{"inputs":[{"name":"m"},{"generics":["syncsender"],"name":"option"},{"name":"bool"}],"output":{"name":"envelope"}}],[11,"stop","","Stop actor execution",6,{"inputs":[{"name":"self"}],"output":null}],[11,"terminate","","Terminate actor execution",6,{"inputs":[{"name":"self"}],"output":null}],[11,"state","","Actor execution state",6,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[11,"spawn","","",6,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[11,"wait","","",6,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"cancel_future","","",6,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"unsync_sender","","",6,{"inputs":[{"name":"self"}],"output":{"generics":["contextprotocol"],"name":"unboundedsender"}}],[11,"unsync_address","","",6,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[11,"sync_address","","",6,{"inputs":[{"name":"self"}],"output":{"name":"syncaddress"}}],[11,"send","","Send item to sink. If sink is closed item returned as an error.",6,null],[11,"close","","Gracefully close Framed object. FramedContext will try to send all buffered items and then close. FramedContext::stop() could be used to force stop sending process.",6,{"inputs":[{"name":"self"}],"output":null}],[11,"drain","","Initiate sink drain",6,{"inputs":[{"name":"self"}],"output":{"name":"unsyncreceiver"}}],[11,"take","","Get inner framed object",6,{"inputs":[{"name":"self"}],"output":{"generics":["framed"],"name":"option"}}],[11,"replace","","Replace existing framed object with new object.",6,{"inputs":[{"name":"self"},{"name":"framed"}],"output":null}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"queue","","",null,null],[0,"sync","actix::queue","This is copy of sync/mpsc/",null,null],[3,"Sender","actix::queue::sync","The transmission end of a channel which is used to send values.",null,null],[3,"UnboundedSender","","The transmission end of a channel which is used to send values.",null,null],[3,"Receiver","","The receiving end of a channel which implements the `Stream` trait.",null,null],[3,"UnboundedReceiver","","The receiving end of a channel which implements the `Stream` trait.",null,null],[3,"SendError","","Error type for sending, used when the receiving end of a channel is dropped",null,null],[3,"TrySendError","","Error type returned from `try_send`",null,null],[5,"channel","","Creates an in-memory channel implementation of the `Stream` trait with bounded capacity.",null,null],[5,"unbounded","","Creates an in-memory channel implementation of the `Stream` trait with unbounded capacity.",null,null],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"senderror"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"senderror"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"self"},{"name":"senderror"}],"output":{"name":"bool"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"trysenderror"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"trysenderror"}],"output":{"name":"bool"}}],[11,"ne","","",12,{"inputs":[{"name":"self"},{"name":"trysenderror"}],"output":{"name":"bool"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",11,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"into_inner","","Returns the message that was attempted to be sent but failed.",11,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",12,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"is_full","","Returns true if this error is a result of the channel being full",12,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_disconnected","","Returns true if this error is a result of the receiver being dropped",12,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"into_inner","","Returns the message that was attempted to be sent but failed.",12,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"try_send","","Attempts to send a message on this `Sender<T>` without blocking.",7,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"generics":["trysenderror"],"name":"result"}}],[11,"poll_ready","","Polls the channel to determine if there is guaranteed to be capacity to send at least one item without waiting.",7,{"inputs":[{"name":"self"}],"output":{"generics":["senderror"],"name":"poll"}}],[11,"start_send","","",7,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"generics":["senderror"],"name":"startsend"}}],[11,"poll_complete","","",7,{"inputs":[{"name":"self"}],"output":{"generics":["senderror"],"name":"poll"}}],[11,"close","","",7,{"inputs":[{"name":"self"}],"output":{"generics":["senderror"],"name":"poll"}}],[11,"unbounded_send","","Sends the provided message along this channel.",8,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"generics":["senderror"],"name":"result"}}],[11,"start_send","","",8,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"generics":["senderror"],"name":"startsend"}}],[11,"poll_complete","","",8,{"inputs":[{"name":"self"}],"output":{"generics":["senderror"],"name":"poll"}}],[11,"close","","",8,{"inputs":[{"name":"self"}],"output":{"generics":["senderror"],"name":"poll"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"unboundedsender"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"sender"}}],[11,"drop","","",7,{"inputs":[{"name":"self"}],"output":null}],[11,"close","","Closes the receiving half",9,{"inputs":[{"name":"self"}],"output":null}],[11,"poll","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["option"],"name":"poll"}}],[11,"drop","","",9,{"inputs":[{"name":"self"}],"output":null}],[11,"connected","","",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"sender","","",10,{"inputs":[{"name":"self"}],"output":{"name":"unboundedsender"}}],[11,"close","","Closes the receiving half",10,{"inputs":[{"name":"self"}],"output":null}],[11,"poll","","",10,{"inputs":[{"name":"self"}],"output":{"generics":["option"],"name":"poll"}}],[0,"unsync","actix::queue","This is copy of unsync/mpsc.rs",null,null],[3,"Sender","actix::queue::unsync","The transmission end of a channel.",null,null],[3,"Receiver","","The receiving end of a channel which implements the `Stream` trait.",null,null],[3,"UnboundedSender","","The transmission end of an unbounded channel.",null,null],[3,"UnboundedReceiver","","The receiving end of an unbounded channel.",null,null],[3,"SendError","","Error type for sending, used when the receiving end of a channel is dropped",null,null],[5,"channel","","Creates a bounded in-memory channel with buffered storage.",null,{"inputs":[{"name":"usize"}],"output":{"name":"receiver"}}],[5,"unbounded","","Creates an unbounded in-memory channel with buffered storage.",null,{"inputs":[],"output":{"name":"unboundedreceiver"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"connected","","",13,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"start_send","","",13,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"generics":["senderror"],"name":"startsend"}}],[11,"poll_complete","","",13,{"inputs":[{"name":"self"}],"output":{"generics":["senderror"],"name":"poll"}}],[11,"close","","",13,{"inputs":[{"name":"self"}],"output":{"generics":["senderror"],"name":"poll"}}],[11,"drop","","",13,{"inputs":[{"name":"self"}],"output":null}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"connected","","Check if receiver connected to senders",14,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"sender","","Get the sender half",14,{"inputs":[{"name":"self"}],"output":{"name":"sender"}}],[11,"close","","Closes the receiving half",14,{"inputs":[{"name":"self"}],"output":null}],[11,"is_closed","","Check if the receiving half is closed",14,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"poll","","",14,{"inputs":[{"name":"self"}],"output":{"generics":["option"],"name":"poll"}}],[11,"drop","","",14,{"inputs":[{"name":"self"}],"output":null}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"start_send","","",15,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"generics":["senderror"],"name":"startsend"}}],[11,"poll_complete","","",15,{"inputs":[{"name":"self"}],"output":{"generics":["senderror"],"name":"poll"}}],[11,"close","","",15,{"inputs":[{"name":"self"}],"output":{"generics":["senderror"],"name":"poll"}}],[11,"connected","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"unbounded_send","","Sends the provided message along this channel.",15,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"generics":["senderror"],"name":"result"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"connected","","Check if receiver connected to senders",16,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"sender","","Get the sender half",16,{"inputs":[{"name":"self"}],"output":{"name":"unboundedsender"}}],[11,"close","","Closes the receiving half",16,{"inputs":[{"name":"self"}],"output":null}],[11,"is_closed","","Check if the receiving half is closed",16,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"poll","","",16,{"inputs":[{"name":"self"}],"output":{"generics":["option"],"name":"poll"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",17,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"into_inner","","Returns the message that was attempted to be sent but failed.",17,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"poll","actix","",18,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"poll","","",18,null],[11,"from","","",19,{"inputs":[{"name":"t"}],"output":{"name":"response"}}],[11,"from","","",19,{"inputs":[{"name":"result"}],"output":{"name":"response"}}],[11,"from","","",19,{"inputs":[{"generics":["actorfuture"],"name":"box"}],"output":{"name":"response"}}],[11,"reply","","Create response",19,{"inputs":[{"name":"result"}],"output":{"name":"self"}}],[11,"async_reply","","Create async response",19,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"get","","Query registry for specific actor. Returns address of the actor. If actor is not registered, starts new actor and return address of newly created actor.",20,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[11,"get","","Return addres of the service. If service actor is not running it get started in system arbiter.",21,{"inputs":[{"name":"self"}],"output":{"name":"syncaddress"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"new","","Create new system",22,{"inputs":[{"name":"t"}],"output":{"name":"systemrunner"}}],[11,"handle","","Returns handle to the current event loop.",23,{"inputs":[{"name":"self"}],"output":{"name":"handle"}}],[11,"run","","This function will start event loop and will finish once the `SystemExit` message get received.",23,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"handle","","",22,{"inputs":[{"name":"self"},{"name":"systemexit"},{"name":"context"}],"output":null}],[11,"start","","Start new supervised actor. Depends on `lazy` argument actor could be started immidietly or on first incoming message.",24,null],[11,"start_in","","Start new supervised actor in arbiter's thread. Depends on `lazy` argument actor could be started immidietly or on first incoming message.",24,{"inputs":[{"name":"syncaddress"},{"name":"bool"},{"name":"f"}],"output":{"generics":["syncaddress"],"name":"option"}}],[0,"fut","","Custom `Future` implementation with `Actix` support",null,null],[3,"AndThen","actix::fut","Future for the `and_then` combinator, chaining a computation onto the end of another future which completes successfully.",null,null],[3,"Then","","Future for the `then` combinator, chaining computations on the end of another future regardless of its outcome.",null,null],[3,"Map","","Future for the `map` combinator, changing the type of a future.",null,null],[3,"MapErr","","Future for the `map_err` combinator, changing the error type of a future.",null,null],[3,"DropErr","","",null,null],[3,"FutureResult","","A future representing a value that is immediately ready.",null,null],[3,"StreamMap","","A stream combinator which will change the type of a stream from one type to another.",null,null],[3,"StreamMapErr","","A stream combinator which will change the error type of a stream from one type to another.",null,null],[3,"StreamThen","","A stream combinator which chains a computation onto each item produced by a stream.",null,null],[3,"StreamAndThen","","A stream combinator which chains a computation onto values produced by a stream.",null,null],[3,"StreamFinish","","A combinator used to convert stream into a future, future resolves when stream completes.",null,null],[3,"StreamFold","","A future used to collect all the results of a stream into one generic type.",null,null],[3,"Finish","","A combinator used to convert stream into a future, future resolves when stream completes.",null,null],[3,"FutureWrap","","",null,null],[3,"StreamWrap","","",null,null],[4,"Either","","Combines two different futures yielding the same item and error types into a single type.",null,null],[13,"A","","First branch of the type",25,null],[13,"B","","Second branch of the type",25,null],[5,"result","","Creates a new \"leaf future\" which will resolve with the given result.",null,{"inputs":[{"name":"result"}],"output":{"name":"futureresult"}}],[5,"ok","","Creates a \"leaf future\" from an immediate value of a finished and successful computation.",null,{"inputs":[{"name":"t"}],"output":{"name":"futureresult"}}],[5,"err","","Creates a \"leaf future\" from an immediate value of a failed computation.",null,{"inputs":[{"name":"e"}],"output":{"name":"futureresult"}}],[5,"wrap_future","","Converts normal future into `ActorFuture`",null,{"inputs":[{"name":"f"}],"output":{"name":"futurewrap"}}],[5,"wrap_stream","","Converts normal stream into `ActorStream`",null,{"inputs":[{"name":"s"}],"output":{"name":"streamwrap"}}],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",26,null],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"split","","Splits out the homogeneous type from an either of tuples.",25,null],[11,"poll","","",25,null],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",27,null],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",28,null],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",29,null],[11,"fmt","","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",30,null],[11,"poll","","",31,null],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",32,null],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",33,null],[11,"fmt","","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",34,null],[11,"fmt","","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",35,null],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",36,null],[11,"fmt","","",37,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",37,null],[11,"fmt","","",38,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",38,{"inputs":[{"name":"s"}],"output":{"name":"finish"}}],[11,"poll","","",38,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[8,"ActorFuture","","Trait for types which are a placeholder of a value that may become available at some later point in time.",null,null],[16,"Item","","The type of value that this future will resolved with if it is successful.",39,null],[16,"Error","","The type of error that this future will resolve with if it fails in a normal fashion.",39,null],[16,"Actor","","The actor within which this future runs",39,null],[10,"poll","","",39,null],[11,"map","","Map this future's result to a different type, returning a new future of the resulting type.",39,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"map"}}],[11,"map_err","","Map this future's error to a different error, returning a new future.",39,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"maperr"}}],[11,"drop_err","","Drop this future's error, returning a new future.",39,{"inputs":[{"name":"self"}],"output":{"name":"droperr"}}],[11,"then","","Chain on a computation for when a future finished, passing the result of the future to the provided closure `f`.",39,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"then"}}],[11,"and_then","","Execute another future after this one has resolved successfully.",39,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"andthen"}}],[8,"ActorStream","","A stream of values, not all of which may have been produced yet.",null,null],[16,"Item","","The type of item this stream will yield on success.",40,null],[16,"Error","","The type of error this stream may generate.",40,null],[16,"Actor","","The actor within which this stream runs.",40,null],[10,"poll","","",40,null],[11,"map","","Converts a stream of type `T` to a stream of type `U`.",40,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"streammap"}}],[11,"map_err","","Converts a stream of error type `T` to a stream of error type `E`.",40,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"streammaperr"}}],[11,"then","","Chain on a computation for when a value is ready, passing the resulting item to the provided closure `f`.",40,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"streamthen"}}],[11,"and_then","","Chain on a computation for when a value is ready, passing the successful results to the provided closure `f`.",40,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"streamandthen"}}],[11,"fold","","Execute an accumulating computation over a stream, collecting all the values into one final result.",40,{"inputs":[{"name":"self"},{"name":"t"},{"name":"f"}],"output":{"name":"streamfold"}}],[11,"finish","","Converts a stream to a future that resolves when stream completes.",40,{"inputs":[{"name":"self"}],"output":{"name":"streamfinish"}}],[8,"IntoActorFuture","","Class of types which can be converted into an actor future.",null,null],[16,"Future","","The future that this type can be converted into.",41,null],[16,"Item","","The item that the future may resolve with.",41,null],[16,"Error","","The error that the future may resolve with.",41,null],[16,"Actor","","The actor within which this future runs",41,null],[10,"into_future","","Consumes this object and produces a future.",41,null],[8,"WrapFuture","","Helper trait that allows conversion of normal future into `ActorFuture`",null,null],[16,"Future","","The future that this type can be converted into.",42,null],[16,"Item","","The item that the future may resolve with.",42,null],[16,"Error","","The error that the future may resolve with.",42,null],[10,"actfuture","","",42,null],[8,"WrapStream","","Helper trait that allows conversion of normal stream into `ActorStream`",null,null],[16,"Stream","","The stream that this type can be converted into.",43,null],[16,"Item","","The item that the future may resolve with.",43,null],[16,"Error","","The error that the future may resolve with.",43,null],[10,"actstream","","",43,null],[11,"poll","","",44,null],[11,"poll","","",45,null],[0,"actors","actix","Helper actors",null,null],[0,"signal","actix::actors","An actor implementation of Unix signal handling",null,null],[3,"Signal","actix::actors::signal","Process signal message",null,null],[12,"0","","",46,null],[3,"ProcessSignals","","An actor implementation of Unix signal handling",null,null],[3,"Subscribe","","Subscribe to process signals.",null,null],[12,"0","","",47,null],[3,"DefaultSignalsHandler","","Default signals handler. This actor sends `SystemExit` message to `System` actor for each of `SIGINT`, `SIGTERM`, `SIGQUIT` signals.",null,null],[4,"SignalType","","Different types of process signals",null,null],[13,"Hup","","SIGHUP",48,null],[13,"Int","","SIGINT",48,null],[13,"Term","","SIGTERM",48,null],[13,"Quit","","SIGQUIT",48,null],[13,"Child","","SIGCHILD",48,null],[11,"eq","","",48,{"inputs":[{"name":"self"},{"name":"signaltype"}],"output":{"name":"bool"}}],[11,"clone","","",48,{"inputs":[{"name":"self"}],"output":{"name":"signaltype"}}],[11,"fmt","","",48,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",49,{"inputs":[],"output":{"name":"self"}}],[11,"service_started","","",49,null],[11,"handle","","",49,null],[11,"default","","",50,{"inputs":[],"output":{"name":"self"}}],[11,"started","","",50,null],[11,"handle","","",50,null],[0,"dns","actix::actors","DNS lookup utils",null,null],[3,"DnsResolver","actix::actors::dns","DNS lookup actor",null,null],[3,"GetAddressInfo","","Request address info lookup message",null,null],[3,"AddrInfo","","Resolved address information",null,null],[12,"flags","","",51,null],[12,"family","","",51,null],[12,"socktype","","",51,null],[12,"protocol","","",51,null],[12,"sockaddr","","",51,null],[12,"canonname","","",51,null],[4,"Family","","Address family",null,null],[13,"Unspec","","Unspecified",52,null],[13,"Inet","","Ipv4",52,null],[13,"Inet6","","Ipv6",52,null],[13,"Unix","","Unix domain soxket",52,null],[13,"Other","","Some other",52,null],[4,"SocketType","","Types of Sockets",null,null],[13,"Stream","","Sequenced, reliable, connection-based byte streams.",53,null],[13,"DGram","","Connectionless, unreliable datagrams of fixed max length.",53,null],[13,"Raw","","Raw protocol interface.",53,null],[13,"Other","","Some other",53,null],[4,"Protocol","","Socket Protocol",null,null],[13,"Unspec","","Unspecified.",54,null],[13,"Local","","Local to host (pipes and file-domain).",54,null],[13,"Unix","","POSIX name for PF_LOCAL.",54,null],[13,"Inet","","IP Protocol Family.",54,null],[13,"TCP","","",54,null],[13,"UDP","","",54,null],[13,"Other","","",54,null],[4,"LookupError","","Errors that can occur looking up a hostname.",null,null],[13,"IOError","","A generic IO error",55,null],[13,"NulError","","A Null Error",55,null],[13,"Other","","Other error",55,null],[13,"Generic","","An unspecific error",55,null],[17,"AI_PASSIVE","","",null,null],[17,"AI_CANONNAME","","",null,null],[17,"AI_NUMERICHOST","","",null,null],[17,"AI_NUMERICSERV","","",null,null],[11,"new","","",56,{"inputs":[{"generics":["string"],"name":"option"},{"generics":["string"],"name":"option"},{"name":"c_int"},{"name":"c_int"},{"name":"sockettype"}],"output":{"name":"self"}}],[11,"handle","","",57,null],[11,"clone","","",52,{"inputs":[{"name":"self"}],"output":{"name":"family"}}],[11,"fmt","","",52,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_int","","",52,{"inputs":[{"name":"c_int"}],"output":{"name":"self"}}],[11,"to_int","","",52,{"inputs":[{"name":"self"}],"output":{"name":"c_int"}}],[11,"clone","","",53,{"inputs":[{"name":"self"}],"output":{"name":"sockettype"}}],[11,"fmt","","",53,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_int","","",53,{"inputs":[{"name":"c_int"}],"output":{"name":"self"}}],[11,"to_int","","",53,{"inputs":[{"name":"self"}],"output":{"name":"c_int"}}],[11,"clone","","",54,{"inputs":[{"name":"self"}],"output":{"name":"protocol"}}],[11,"fmt","","",54,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_int","","",54,{"inputs":[{"name":"c_int"}],"output":{"name":"self"}}],[11,"to_int","","",54,{"inputs":[{"name":"self"}],"output":{"name":"c_int"}}],[11,"clone","","",51,{"inputs":[{"name":"self"}],"output":{"name":"addrinfo"}}],[11,"fmt","","",51,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",51,{"inputs":[{"name":"c_int"},{"name":"family"},{"name":"sockettype"},{"name":"protocol"},{"name":"socketaddr"},{"generics":["string"],"name":"option"}],"output":{"name":"addrinfo"}}],[11,"from","","",55,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"from","","",55,{"inputs":[{"name":"nulerror"}],"output":{"name":"self"}}],[11,"from","","",55,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"description","","",55,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",55,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[11,"fmt","","",55,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",55,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"msgs","actix","Actix system messages",null,null],[3,"SystemExit","actix::msgs","Stop system execution",null,null],[12,"0","","",58,null],[3,"StopArbiter","","Stop arbiter execution",null,null],[12,"0","","",59,null],[3,"StartActor","","Start actor in arbiter's thread",null,null],[3,"Execute","","Execute function in arbiter's thread",null,null],[11,"new","","",60,{"inputs":[{"name":"f"}],"output":{"name":"self"}}],[11,"new","","",61,{"inputs":[{"name":"f"}],"output":{"name":"self"}}],[11,"exec","","Execute enclosed function",61,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[0,"sync","actix","Sync actors support",null,null],[3,"SyncArbiter","actix::sync","Sync arbiter",null,null],[3,"SyncContext","","Sync actor execution context",null,null],[11,"start","","Start new sync arbiter with specified number of worker threads. Returns address of started actor.",62,{"inputs":[{"name":"usize"},{"name":"f"}],"output":{"name":"syncaddress"}}],[11,"pack","","",63,{"inputs":[{"name":"m"},{"generics":["syncsender"],"name":"option"},{"name":"bool"}],"output":{"name":"envelope"}}],[11,"restart","","Initiate actor restart process.",63,{"inputs":[{"name":"self"}],"output":null}],[11,"stop","","Stop actor execution",63,{"inputs":[{"name":"self"}],"output":null}],[11,"terminate","","Terminate actor execution",63,{"inputs":[{"name":"self"}],"output":null}],[11,"state","","Actor execution state",63,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[0,"prelude","actix","The `actix` prelude",null,null],[3,"Arbiter","actix::prelude","Event loop controller",null,null],[3,"Address","","Address of the actor",null,null],[3,"SyncAddress","","`Send` address of the actor. Actor can run in differend thread",null,null],[3,"FramedContext","","Actor execution context for Framed object",null,null],[3,"Response","","`Response` represents asyncronous message handling process.",null,null],[3,"Context","","Actor execution context",null,null],[3,"System","","System is an actor which manages process.",null,null],[0,"actix","","",null,null],[3,"SpawnHandle","actix::prelude::actix","Spawned future handle. Could be used for cancelling spawned future.",null,null],[3,"Arbiter","","Event loop controller",null,null],[3,"Address","","Address of the actor",null,null],[3,"SyncAddress","","`Send` address of the actor. Actor can run in differend thread",null,null],[3,"Context","","Actor execution context",null,null],[3,"FramedContext","","Actor execution context for Framed object",null,null],[3,"Request","","`Request` is a `Future` which represents asyncronous message sending process.",null,null],[3,"Response","","`Response` represents asyncronous message handling process.",null,null],[3,"System","","System is an actor which manages process.",null,null],[4,"ActorState","","Actor execution state",null,null],[13,"Started","","Actor is started.",0,null],[13,"Running","","Actor is running.",0,null],[13,"Stopping","","Actor is stopping.",0,null],[13,"Stopped","","Actor is stopped.",0,null],[6,"MessageResult","","",null,null],[6,"ResponseFuture","","",null,null],[8,"Actor","","Actors are objects which encapsulate state and behavior.",null,null],[16,"Context","","Actor execution context type",64,null],[11,"started","","Method is called when actor get polled first time.",64,null],[11,"stopping","","Method is called after an actor is in `Actor::Stopping` state. There could be several reasons for stopping. `Context::stop` get called by the actor itself. All addresses to current actor get dropped and no more evented objects left in the context.",64,null],[11,"stopped","","Method is called after an actor is stopped, it can be used to perform any needed cleanup work or spawning more actors. This is final state, after this call actor get dropped.",64,null],[11,"start","","Start new asynchronous actor, returns address of newly created actor.",64,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[11,"start_default","","Start new asynchronous actor, returns address of newly created actor.",64,{"inputs":[],"output":{"name":"addr"}}],[11,"create","","Use `create` method, if you need `Context` object during actor initialization.",64,{"inputs":[{"name":"f"}],"output":{"name":"addr"}}],[11,"reply","","Create static response.",64,{"inputs":[{"name":"result"}],"output":{"name":"response"}}],[11,"async_reply","","Create async response process.",64,{"inputs":[{"name":"t"}],"output":{"name":"response"}}],[8,"FramedActor","","Actor trait that allows to handle `tokio_io::codec::Framed` objects.",null,null],[16,"Io","","Io type",65,null],[16,"Codec","","Codec type",65,null],[10,"handle","","This message is called for every decoded message from framed object.",65,null],[11,"closed","","This method is called when framed object get closed.",65,null],[11,"framed","","Start new actor, returns address of this actor.",65,null],[11,"from_framed","","Start new actor, returns address of this actor.",65,{"inputs":[{"name":"self"},{"name":"framed"}],"output":{"name":"addr"}}],[11,"create_framed","","This function starts new actor, returns address of this actor. Actor is created by factory function.",65,null],[11,"create_from_framed","","This function starts new actor, returns address of this actor. Actor is created by factory function.",65,{"inputs":[{"name":"framed"},{"name":"f"}],"output":{"name":"addr"}}],[8,"Supervised","","Actors with ability to restart after failure",null,null],[11,"restarting","","Method called when supervisor restarting failed actor",66,null],[8,"ActorContext","","Actor execution context",null,null],[10,"stop","","Gracefully stop actor execution",67,{"inputs":[{"name":"self"}],"output":null}],[10,"terminate","","Terminate actor execution",67,{"inputs":[{"name":"self"}],"output":null}],[10,"state","","Actor execution state",67,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[11,"alive","","Check if execution context is alive",67,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"AsyncContext","","Asynchronous execution context",null,null],[11,"address","","Get actor address",68,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[10,"spawn","","Spawn async future into context. Returns handle of the item, could be used for cancelling execution.",68,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[10,"wait","","Spawn future into the context. Stop processing any of incoming events until this future resolves.",68,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[10,"cancel_future","","Cancel future. idx is a value returned by `spawn` method.",68,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"add_future","","This method allow to handle Future in similar way as normal actor messages.",68,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"add_stream","","This method is similar to `add_future` but works with streams.",68,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"add_message_stream","","This method is similar to `add_stream` but it skips errors.",68,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"notify","","Send message `msg` to self.",68,{"inputs":[{"name":"self"},{"name":"m"}],"output":null}],[11,"notify_later","","Send message `msg` to self after specified period of time. Returns spawn handle which could be used for cancelation. Notification get cancelled if context's stop method get called.",68,{"inputs":[{"name":"self"},{"name":"m"},{"name":"duration"}],"output":{"name":"spawnhandle"}}],[11,"run_later","","Execute closure after specified period of time within same Actor and Context Execution get cancelled if context's stop method get called.",68,{"inputs":[{"name":"self"},{"name":"duration"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[8,"Handler","","Message handler",null,null],[16,"Result","","",69,null],[10,"handle","","Method is called for every message received by this Actor",69,null],[8,"ResponseType","","Message response type",null,null],[16,"Item","","The type of value that this message will resolved with if it is successful.",70,null],[16,"Error","","The type of error that this message will resolve with if it fails in a normal fashion.",70,null],[8,"Subscriber","","",null,null],[10,"send","","Send buffered message",71,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"name":"result"}}],[10,"boxed","","Create boxed clone of the current subscriber",71,{"inputs":[{"name":"self"}],"output":{"generics":["subscriber"],"name":"box"}}],[8,"ActorAddress","","Trait give access to actor's address",null,null],[10,"get","","Returns actor's address for specific context",72,null],[8,"ContextFutureSpawner","","Helper trait which can spawn future into actor's context",null,null],[10,"spawn","","spawn future into `Context<A>`",73,null],[10,"wait","","Spawn future into the context. Stop processing any of incoming events until this future resolves.",73,null],[8,"ArbiterService","","Trait defines arbiter's service.",null,null],[11,"service_started","","Method is called during service initialization.",74,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[8,"SystemService","","Trait defines system's service.",null,null],[11,"service_started","","Method is called during service initialization.",75,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[6,"MessageResult","actix::prelude","",null,null],[6,"ResponseFuture","","",null,null],[8,"Actor","","Actors are objects which encapsulate state and behavior.",null,null],[16,"Context","","Actor execution context type",64,null],[11,"started","actix::prelude::actix","Method is called when actor get polled first time.",64,null],[11,"stopping","","Method is called after an actor is in `Actor::Stopping` state. There could be several reasons for stopping. `Context::stop` get called by the actor itself. All addresses to current actor get dropped and no more evented objects left in the context.",64,null],[11,"stopped","","Method is called after an actor is stopped, it can be used to perform any needed cleanup work or spawning more actors. This is final state, after this call actor get dropped.",64,null],[11,"start","","Start new asynchronous actor, returns address of newly created actor.",64,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[11,"start_default","","Start new asynchronous actor, returns address of newly created actor.",64,{"inputs":[],"output":{"name":"addr"}}],[11,"create","","Use `create` method, if you need `Context` object during actor initialization.",64,{"inputs":[{"name":"f"}],"output":{"name":"addr"}}],[11,"reply","","Create static response.",64,{"inputs":[{"name":"result"}],"output":{"name":"response"}}],[11,"async_reply","","Create async response process.",64,{"inputs":[{"name":"t"}],"output":{"name":"response"}}],[8,"ActorContext","actix::prelude","Actor execution context",null,null],[10,"stop","","Gracefully stop actor execution",67,{"inputs":[{"name":"self"}],"output":null}],[10,"terminate","","Terminate actor execution",67,{"inputs":[{"name":"self"}],"output":null}],[10,"state","","Actor execution state",67,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[11,"alive","actix::prelude::actix","Check if execution context is alive",67,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"AsyncContext","actix::prelude","Asynchronous execution context",null,null],[11,"address","actix::prelude::actix","Get actor address",68,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[10,"spawn","actix::prelude","Spawn async future into context. Returns handle of the item, could be used for cancelling execution.",68,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[10,"wait","","Spawn future into the context. Stop processing any of incoming events until this future resolves.",68,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[10,"cancel_future","","Cancel future. idx is a value returned by `spawn` method.",68,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"add_future","actix::prelude::actix","This method allow to handle Future in similar way as normal actor messages.",68,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"add_stream","","This method is similar to `add_future` but works with streams.",68,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"add_message_stream","","This method is similar to `add_stream` but it skips errors.",68,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"notify","","Send message `msg` to self.",68,{"inputs":[{"name":"self"},{"name":"m"}],"output":null}],[11,"notify_later","","Send message `msg` to self after specified period of time. Returns spawn handle which could be used for cancelation. Notification get cancelled if context's stop method get called.",68,{"inputs":[{"name":"self"},{"name":"m"},{"name":"duration"}],"output":{"name":"spawnhandle"}}],[11,"run_later","","Execute closure after specified period of time within same Actor and Context Execution get cancelled if context's stop method get called.",68,{"inputs":[{"name":"self"},{"name":"duration"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[8,"FramedActor","actix::prelude","Actor trait that allows to handle `tokio_io::codec::Framed` objects.",null,null],[16,"Io","","Io type",65,null],[16,"Codec","","Codec type",65,null],[10,"handle","","This message is called for every decoded message from framed object.",65,null],[11,"closed","actix::prelude::actix","This method is called when framed object get closed.",65,null],[11,"framed","","Start new actor, returns address of this actor.",65,null],[11,"from_framed","","Start new actor, returns address of this actor.",65,{"inputs":[{"name":"self"},{"name":"framed"}],"output":{"name":"addr"}}],[11,"create_framed","","This function starts new actor, returns address of this actor. Actor is created by factory function.",65,null],[11,"create_from_framed","","This function starts new actor, returns address of this actor. Actor is created by factory function.",65,{"inputs":[{"name":"framed"},{"name":"f"}],"output":{"name":"addr"}}],[8,"Handler","actix::prelude","Message handler",null,null],[16,"Result","","",69,null],[10,"handle","","Method is called for every message received by this Actor",69,null],[8,"ResponseType","","Message response type",null,null],[16,"Item","","The type of value that this message will resolved with if it is successful.",70,null],[16,"Error","","The type of error that this message will resolve with if it fails in a normal fashion.",70,null],[8,"ContextFutureSpawner","","Helper trait which can spawn future into actor's context",null,null],[10,"spawn","","spawn future into `Context<A>`",73,null],[10,"wait","","Spawn future into the context. Stop processing any of incoming events until this future resolves.",73,null],[0,"dev","actix","The `actix` prelude for library developers",null,null],[3,"ContextImpl","actix::dev","Actor execution context impl",null,null],[3,"ActorAddressCell","","",null,null],[3,"ActorItemsCell","","",null,null],[3,"ActorWaitCell","","",null,null],[3,"Envelope","","",null,null],[3,"RemoteEnvelope","","",null,null],[4,"ContextProtocol","","context protocol",null,null],[13,"Envelope","","message envelope",76,null],[13,"Upgrade","","Request sync address",76,null],[4,"ContextCellResult","","",null,null],[13,"NotReady","","",77,null],[13,"Ready","","",77,null],[13,"Stop","","",77,null],[8,"ActorAddress","","Trait give access to actor's address",null,null],[10,"get","","Returns actor's address for specific context",72,null],[8,"AsyncContextApi","","",null,null],[10,"unsync_sender","","",78,{"inputs":[{"name":"self"}],"output":{"generics":["contextprotocol"],"name":"unboundedsender"}}],[10,"unsync_address","","",78,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[10,"sync_address","","",78,{"inputs":[{"name":"self"}],"output":{"name":"syncaddress"}}],[8,"ToEnvelope","","Converter trait, packs message to suitable envelope",null,null],[10,"pack","","Pack message into suitable envelope",79,{"inputs":[{"name":"m"},{"generics":["syncsender"],"name":"option"},{"name":"bool"}],"output":{"name":"envelope"}}],[6,"MessageResult","actix","",null,null],[6,"ResponseFuture","","",null,null],[8,"Actor","","Actors are objects which encapsulate state and behavior.",null,null],[16,"Context","","Actor execution context type",64,null],[11,"started","actix::prelude::actix","Method is called when actor get polled first time.",64,null],[11,"stopping","","Method is called after an actor is in `Actor::Stopping` state. There could be several reasons for stopping. `Context::stop` get called by the actor itself. All addresses to current actor get dropped and no more evented objects left in the context.",64,null],[11,"stopped","","Method is called after an actor is stopped, it can be used to perform any needed cleanup work or spawning more actors. This is final state, after this call actor get dropped.",64,null],[11,"start","","Start new asynchronous actor, returns address of newly created actor.",64,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[11,"start_default","","Start new asynchronous actor, returns address of newly created actor.",64,{"inputs":[],"output":{"name":"addr"}}],[11,"create","","Use `create` method, if you need `Context` object during actor initialization.",64,{"inputs":[{"name":"f"}],"output":{"name":"addr"}}],[11,"reply","","Create static response.",64,{"inputs":[{"name":"result"}],"output":{"name":"response"}}],[11,"async_reply","","Create async response process.",64,{"inputs":[{"name":"t"}],"output":{"name":"response"}}],[8,"FramedActor","actix","Actor trait that allows to handle `tokio_io::codec::Framed` objects.",null,null],[16,"Io","","Io type",65,null],[16,"Codec","","Codec type",65,null],[10,"handle","","This message is called for every decoded message from framed object.",65,null],[11,"closed","actix::prelude::actix","This method is called when framed object get closed.",65,null],[11,"framed","","Start new actor, returns address of this actor.",65,null],[11,"from_framed","","Start new actor, returns address of this actor.",65,{"inputs":[{"name":"self"},{"name":"framed"}],"output":{"name":"addr"}}],[11,"create_framed","","This function starts new actor, returns address of this actor. Actor is created by factory function.",65,null],[11,"create_from_framed","","This function starts new actor, returns address of this actor. Actor is created by factory function.",65,{"inputs":[{"name":"framed"},{"name":"f"}],"output":{"name":"addr"}}],[8,"Supervised","actix","Actors with ability to restart after failure",null,null],[11,"restarting","actix::prelude::actix","Method called when supervisor restarting failed actor",66,null],[8,"ActorContext","actix","Actor execution context",null,null],[10,"stop","","Gracefully stop actor execution",67,{"inputs":[{"name":"self"}],"output":null}],[10,"terminate","","Terminate actor execution",67,{"inputs":[{"name":"self"}],"output":null}],[10,"state","","Actor execution state",67,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[11,"alive","actix::prelude::actix","Check if execution context is alive",67,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"AsyncContext","actix","Asynchronous execution context",null,null],[11,"address","actix::prelude::actix","Get actor address",68,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[10,"spawn","actix","Spawn async future into context. Returns handle of the item, could be used for cancelling execution.",68,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[10,"wait","","Spawn future into the context. Stop processing any of incoming events until this future resolves.",68,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[10,"cancel_future","","Cancel future. idx is a value returned by `spawn` method.",68,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"add_future","actix::prelude::actix","This method allow to handle Future in similar way as normal actor messages.",68,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"add_stream","","This method is similar to `add_future` but works with streams.",68,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"add_message_stream","","This method is similar to `add_stream` but it skips errors.",68,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"notify","","Send message `msg` to self.",68,{"inputs":[{"name":"self"},{"name":"m"}],"output":null}],[11,"notify_later","","Send message `msg` to self after specified period of time. Returns spawn handle which could be used for cancelation. Notification get cancelled if context's stop method get called.",68,{"inputs":[{"name":"self"},{"name":"m"},{"name":"duration"}],"output":{"name":"spawnhandle"}}],[11,"run_later","","Execute closure after specified period of time within same Actor and Context Execution get cancelled if context's stop method get called.",68,{"inputs":[{"name":"self"},{"name":"duration"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[8,"Handler","actix","Message handler",null,null],[16,"Result","","",69,null],[10,"handle","","Method is called for every message received by this Actor",69,null],[8,"ResponseType","","Message response type",null,null],[16,"Item","","The type of value that this message will resolved with if it is successful.",70,null],[16,"Error","","The type of error that this message will resolve with if it fails in a normal fashion.",70,null],[8,"Subscriber","","",null,null],[10,"send","","Send buffered message",71,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"name":"result"}}],[10,"boxed","","Create boxed clone of the current subscriber",71,{"inputs":[{"name":"self"}],"output":{"generics":["subscriber"],"name":"box"}}],[8,"ActorAddress","","Trait give access to actor's address",null,null],[10,"get","","Returns actor's address for specific context",72,null],[8,"ContextFutureSpawner","","Helper trait which can spawn future into actor's context",null,null],[10,"spawn","","spawn future into `Context<A>`",73,null],[10,"wait","","Spawn future into the context. Stop processing any of incoming events until this future resolves.",73,null],[8,"ToEnvelope","","Converter trait, packs message to suitable envelope",null,null],[10,"pack","","Pack message into suitable envelope",79,{"inputs":[{"name":"m"},{"generics":["syncsender"],"name":"option"},{"name":"bool"}],"output":{"name":"envelope"}}],[8,"ArbiterService","","Trait defines arbiter's service.",null,null],[11,"service_started","actix::prelude::actix","Method is called during service initialization.",74,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[8,"SystemService","actix","Trait defines system's service.",null,null],[11,"service_started","actix::prelude::actix","Method is called during service initialization.",75,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[11,"started","","Method is called when actor get polled first time.",64,null],[11,"stopping","","Method is called after an actor is in `Actor::Stopping` state. There could be several reasons for stopping. `Context::stop` get called by the actor itself. All addresses to current actor get dropped and no more evented objects left in the context.",64,null],[11,"stopped","","Method is called after an actor is stopped, it can be used to perform any needed cleanup work or spawning more actors. This is final state, after this call actor get dropped.",64,null],[11,"start","","Start new asynchronous actor, returns address of newly created actor.",64,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[11,"start_default","","Start new asynchronous actor, returns address of newly created actor.",64,{"inputs":[],"output":{"name":"addr"}}],[11,"create","","Use `create` method, if you need `Context` object during actor initialization.",64,{"inputs":[{"name":"f"}],"output":{"name":"addr"}}],[11,"reply","","Create static response.",64,{"inputs":[{"name":"result"}],"output":{"name":"response"}}],[11,"async_reply","","Create async response process.",64,{"inputs":[{"name":"t"}],"output":{"name":"response"}}],[11,"closed","","This method is called when framed object get closed.",65,null],[11,"framed","","Start new actor, returns address of this actor.",65,null],[11,"from_framed","","Start new actor, returns address of this actor.",65,{"inputs":[{"name":"self"},{"name":"framed"}],"output":{"name":"addr"}}],[11,"create_framed","","This function starts new actor, returns address of this actor. Actor is created by factory function.",65,null],[11,"create_from_framed","","This function starts new actor, returns address of this actor. Actor is created by factory function.",65,{"inputs":[{"name":"framed"},{"name":"f"}],"output":{"name":"addr"}}],[11,"restarting","","Method called when supervisor restarting failed actor",66,null],[11,"alive","","Check if execution context is alive",67,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"address","","Get actor address",68,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[11,"add_future","","This method allow to handle Future in similar way as normal actor messages.",68,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"add_stream","","This method is similar to `add_future` but works with streams.",68,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"add_message_stream","","This method is similar to `add_stream` but it skips errors.",68,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"notify","","Send message `msg` to self.",68,{"inputs":[{"name":"self"},{"name":"m"}],"output":null}],[11,"notify_later","","Send message `msg` to self after specified period of time. Returns spawn handle which could be used for cancelation. Notification get cancelled if context's stop method get called.",68,{"inputs":[{"name":"self"},{"name":"m"},{"name":"duration"}],"output":{"name":"spawnhandle"}}],[11,"run_later","","Execute closure after specified period of time within same Actor and Context Execution get cancelled if context's stop method get called.",68,{"inputs":[{"name":"self"},{"name":"duration"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[11,"new","actix::dev","",80,{"inputs":[{"name":"option"}],"output":{"name":"contextimpl"}}],[11,"with_cell","","",80,{"inputs":[{"name":"option"},{"name":"c"}],"output":{"name":"contextimpl"}}],[11,"with_receiver","","",80,{"inputs":[{"name":"option"},{"generics":["envelope"],"name":"unboundedreceiver"}],"output":{"name":"contextimpl"}}],[11,"actor","","",80,{"inputs":[{"name":"self"}],"output":{"name":"a"}}],[11,"cell","","",80,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"modify","","",80,{"inputs":[{"name":"self"}],"output":null}],[11,"stop","","Stop actor execution",80,{"inputs":[{"name":"self"}],"output":null}],[11,"terminate","","Terminate actor execution",80,{"inputs":[{"name":"self"}],"output":null}],[11,"state","","Actor execution state",80,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[11,"spawn","","",80,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[11,"wait","","",80,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"cancel_future","","",80,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"unsync_sender","","",80,{"inputs":[{"name":"self"}],"output":{"generics":["contextprotocol"],"name":"unboundedsender"}}],[11,"unsync_address","","",80,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[11,"sync_address","","",80,{"inputs":[{"name":"self"}],"output":{"name":"syncaddress"}}],[11,"subscriber","","",80,{"inputs":[{"name":"self"}],"output":{"generics":["subscriber"],"name":"box"}}],[11,"sync_subscriber","","",80,{"inputs":[{"name":"self"}],"output":{"generics":["subscriber"],"name":"box"}}],[11,"alive","","",80,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_actor","","",80,{"inputs":[{"name":"self"},{"name":"a"}],"output":null}],[11,"into_inner","","",80,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"started","","",80,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"poll","","",80,null],[11,"fmt","","",77,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",77,{"inputs":[{"name":"self"},{"name":"contextcellresult"}],"output":{"name":"bool"}}],[11,"default","","",81,{"inputs":[],"output":{"name":"self"}}],[11,"new","","",81,{"inputs":[{"generics":["envelope"],"name":"unboundedreceiver"}],"output":{"name":"self"}}],[11,"close","","",81,{"inputs":[{"name":"self"}],"output":null}],[11,"connected","","",81,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"unsync_sender","","",81,{"inputs":[{"name":"self"}],"output":{"generics":["contextprotocol"],"name":"unboundedsender"}}],[11,"unsync_address","","",81,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[11,"sync_address","","",81,{"inputs":[{"name":"self"}],"output":{"name":"syncaddress"}}],[11,"poll","","",81,null],[11,"default","","",82,{"inputs":[],"output":{"name":"self"}}],[11,"is_empty","","",82,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"spawn","","",82,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[11,"cancel_future","","",82,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"poll","","",82,null],[11,"default","","",83,{"inputs":[],"output":{"name":"actorwaitcell"}}],[11,"is_empty","","",83,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"add","","",83,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"poll","","",83,null],[11,"new","","",84,{"inputs":[{"name":"m"},{"generics":["syncsender"],"name":"option"},{"name":"bool"}],"output":{"name":"remoteenvelope"}}],[11,"from","","",85,{"inputs":[{"name":"remoteenvelope"}],"output":{"name":"self"}}],[11,"service_started","actix::prelude::actix","Method is called during service initialization.",74,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[11,"service_started","","Method is called during service initialization.",75,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}]],"paths":[[4,"ActorState"],[3,"SpawnHandle"],[3,"Arbiter"],[3,"Address"],[3,"SyncAddress"],[3,"Context"],[3,"FramedContext"],[3,"Sender"],[3,"UnboundedSender"],[3,"Receiver"],[3,"UnboundedReceiver"],[3,"SendError"],[3,"TrySendError"],[3,"Sender"],[3,"Receiver"],[3,"UnboundedSender"],[3,"UnboundedReceiver"],[3,"SendError"],[3,"Request"],[3,"Response"],[3,"Registry"],[3,"SystemRegistry"],[3,"System"],[3,"SystemRunner"],[3,"Supervisor"],[4,"Either"],[3,"AndThen"],[3,"FutureResult"],[3,"Then"],[3,"Map"],[3,"MapErr"],[3,"DropErr"],[3,"StreamMap"],[3,"StreamMapErr"],[3,"StreamThen"],[3,"StreamAndThen"],[3,"StreamFinish"],[3,"StreamFold"],[3,"Finish"],[8,"ActorFuture"],[8,"ActorStream"],[8,"IntoActorFuture"],[8,"WrapFuture"],[8,"WrapStream"],[3,"FutureWrap"],[3,"StreamWrap"],[3,"Signal"],[3,"Subscribe"],[4,"SignalType"],[3,"ProcessSignals"],[3,"DefaultSignalsHandler"],[3,"AddrInfo"],[4,"Family"],[4,"SocketType"],[4,"Protocol"],[4,"LookupError"],[3,"GetAddressInfo"],[3,"DnsResolver"],[3,"SystemExit"],[3,"StopArbiter"],[3,"StartActor"],[3,"Execute"],[3,"SyncArbiter"],[3,"SyncContext"],[8,"Actor"],[8,"FramedActor"],[8,"Supervised"],[8,"ActorContext"],[8,"AsyncContext"],[8,"Handler"],[8,"ResponseType"],[8,"Subscriber"],[8,"ActorAddress"],[8,"ContextFutureSpawner"],[8,"ArbiterService"],[8,"SystemService"],[4,"ContextProtocol"],[4,"ContextCellResult"],[8,"AsyncContextApi"],[8,"ToEnvelope"],[3,"ContextImpl"],[3,"ActorAddressCell"],[3,"ActorItemsCell"],[3,"ActorWaitCell"],[3,"RemoteEnvelope"],[3,"Envelope"]]};
initSearch(searchIndex);
